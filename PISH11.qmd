# ООП. Наследование и полиморфизм

## Введение

Наследование - принцип ООП, согласно которому класс-наследник может получать функции и переменные от класса-родителя. Класс-родитель является более абстрактной моделью. Класс-наследник является более конкретной реализацией. Создавая иерархии классов, мы создаем множество моделей одного абстрактного явления. Множество форм - полиморфизм.

```{python}
class Animal():
    pass

class Cat(Animal): #класс-родитель указывается в круглых скобках
    pass
```

Классы наследуют от родителей переменные и функции, которые располагаются в public и protected областях.

```{python}
class Animal():

    def exclaim(self):
        print('I am Animal!')

class Cat(Animal): #класс-родитель указывается в круглых скобках
    pass
    # класс Cat также имеет метод exclaim

animal = Animal()
animal.exclaim()

cat = Cat()
cat.exclaim()
```

Классам-наследникам бывает необходимо изменять унаследованное поведение, **переопределяя** унаследованные функции, таким образом создавая множество форм (полиморфизм). Переопределить можно любой унаследованный метод.

```{python}
class Animal():

    def exclaim(self):
        print('I am Animal!')

class Cat(Animal): #класс-родитель указывается в круглых скобках
    
    def exclaim(self):
        print('I am Cat! Child of Animal!')

animal = Animal()
animal.exclaim()

cat = Cat()
cat.exclaim()
```

Класс-наследник может иметь функции, которых нет в классе-родителе.

```{python}
class Animal():

    def exclaim(self):
        print('I am Animal!')

class Cat(Animal): #класс-родитель указывается в круглых скобках
    
    def exclaim(self):
        print('I am Cat! Child of Animal!')

    def purr(self):
        print('Purr purr purr!')

animal = Animal()
animal.exclaim()

cat = Cat()
cat.exclaim()
cat.purr()
```

Класс-потомок может вызвать метод класса-родителя.

```{python}
class Person():
    def __init__(self, name):
        self.name = name

class EmailPerson(Person):
    def __init__(self, name, email):
        super().__init__(name) # вызов родительского конструктора с помощью super()
        self.email = email # появилось доп.свойство в отличие от родителя

bob = EmailPerson('Bob Frapples', 'bob@frapples.com')
print(bob.name)
print(bob.email)
```

Когда вы определяете метод **init**() для своего класса, вы заменяете метод **init**() родительского класса, который больше не вызывается автоматически. В результате вам нужно вызывать его явно. Происходит следующее.

-   Метод super() получает определение родительского класса Person.
-   Метод **init**() вызывает метод Person.\_\_init\_\_(). Последний заботится о том, чтобы передать аргумент self суперклассу, поэтому вам нужно лишь передать опциональные аргументы. В нашем случае единственным аргументом класса Person() будет name.
-   Строка self.email = email — это новый код, который отличает класс EmailPerson от класса Person.

Почему бы нам просто не определить новый класс так, как показано далее?

```{python}
class EmailPerson(Person):
    def __init__(self, name, email):
        self.name = name
        self.email = email
```

Мы могли бы сделать это, но в таком случае потеряли бы возможность применять наследование. Мы использовали метод super(), чтобы создать объект, который работает примерно так же, как и объект класса Person. Есть и другое преимущество: если определение класса Person в будущем изменится, с помощью метода super() мы сможем гарантировать, что атрибуты и методы, которые класс EmailPerson наследует от класса Person, отреагируют на изменения.

Используйте метод super(), когда потомок делает что-то самостоятельно, но ему все еще нужно что-то от предка (как и в реальной жизни)

## Типы методов

Одни данные (*атрибуты*) и функции (*методы*) являются частью самого класса, а другие — частью объектов, которые созданы на его основе. Когда вы видите начальный аргумент self в методах внутри определения класса, этот метод является *методом экземпляра*. Такие методы вы обычно пишете при создании собственного класса. Первый параметр метода экземпляра — это self, и Python передает объект методу, когда вы его вызываете.

В противоположность ему метод класса влияет на весь класс целиком. Любое изменение, которое происходит с классом, влияет на все его объекты. Внутри определения класса декоратор \@classmethod показывает, что следующая функция является методом класса. Первым параметром метода также является сам класс. Согласно традиции этот параметр называется cls, поскольку слово class является зарезервированным и не может быть использовано здесь. Определим метод класса для А, который будет подсчитывать количество созданных объектов:

```{python}
class A():
    count = 0
    
    def __init__(self):
        A.count += 1
    
    def exclaim(self):
        print("I'm an A!")
    
    @classmethod
    def kids(cls):
        print("A has", cls.count, "little objects.")

easy_a = A()
breezy_a = A()
wheezy_a = A()
A.kids()
```

```{python}
easy_a.exclaim()
```

```{python}
A.exclaim(easy_a)
```

Обратите внимание на то, что мы вызвали метод A.count (атрибут класса) вместо self.count (который является атрибутом объекта). В методе kids() мы использовали вызов cls.count, но с тем же успехом могли бы применять вызов A.count.

Третий тип методов не влияет ни на классы, ни на объекты: он находится внутри класса только для удобства вместо того, чтобы располагаться где-то отдельно. Это статический метод, перед которым располагается декоратор \@staticmethod, не имеющий в качестве начального параметра ни self, ни класс class. Рассмотрим пример, который служит в качестве рекламы класса CoyoteWeapon:

```{python}
class CoyoteWeapon():
    @staticmethod
    def commercial():
        print('This CoyoteWeapon has been brought to you by Acme')

CoyoteWeapon.commercial()
```

Обратите внимание на то, что нам не нужно создавать объект класса CoyoteWeapon, чтобы получить доступ к этому методу. Это здорово.

## Магические методы

Теперь вы можете создавать и использовать простые объекты, но опустимся немного глубже и сделаем нечто большее.

Когда вы пишете что-то вроде a = 3 + 8, откуда целочисленные объекты со значениями 3 и 8 узнают, как реализовать операцию +? Кроме того, откуда a знает, как использовать =, чтобы получить результат? Вы можете воспользоваться этими операторами, применяя специальные методы Python (также можно назвать их магическими методами).

Имена этих методов начинаются с двойных подчеркиваний (\_\_) и заканчиваются ими. Вы уже видели один такой метод: \_\_init\_\_ инициализирует только что созданный объект с помощью описания его класса и любых аргументов, которые были переданы в этот метод.

[Полный список методов](http://bit.ly/pydocs-smn)

```{python}
class Word():
    def __init__(self, text):
        self.text = text
        
    def __eq__(self, word2):
        return self.text.lower() == word2.text.lower()
    
    def __str__(self):
        return self.text
    
    def __repr__(self):
        return f'Word("{self.text}")'

first = Word('ha')
```

```{python}
first # используется __repr__
```

```{python}
print(first) # используется __str__
```

## Когда лучше использовать классы и объекты, а когда — модули

Рассмотрим несколько рекомендаций, которые помогут вам понять, где лучше разместить свой код — в классе или в модуле.

-   Объекты наиболее полезны, когда вам нужно иметь некоторое количество отдельных экземпляров с одинаковым поведением (методами), но различающихся внутренним состоянием (атрибутами).

-   Классы, в отличие от модулей, поддерживают наследование.

-   Если вам нужен только один объект, модуль подойдет лучше. Независимо от того, сколько обращений к модулю имеется в программе, будет загружена только одна копия. (Программистам на Java и С++: если вы знакомы с книгой Эриха Гаммы «Приемы объектно-ориентированного проектирования. Паттерны проектирования» (Gamma E. Design Patterns: Elements of Reusable Object-Oriented Software), можете использовать модули в Python как синглтоны.)

-   Если у вас есть несколько переменных, которые содержат разные значения и могут быть переданы как аргументы в несколько функций, лучше всего определить их как классы. Например, вы можете использовать словарь с ключами size и color, чтобы представить цветное изображение. Вы можете создать разные словари для каждого изображения в программе и передавать их в качестве аргументов в функции scale() и transform(). По мере добавления новых ключей и функций может начаться путаница. Более последовательно было бы определить класс Image с атрибутами size или color и методами scale() и transform(). В этом случае все данные и методы для работы с цветными изображениями будут определены в одном месте.

-   Используйте простейшее решение задачи. Словарь, список или кортеж проще, компактнее и быстрее, чем модуль, который, в свою очередь, проще, чем класс

## Для самостоятельного обучения

Кроме особенностей, связанных с наследованием, существуют другие формы реализации полиморфизма в Python.

-   Утиная типизация. Простой Python. Современный стиль программирования (c. 170-171)
-   Перегрузка функций. \[Обучающий материал\](<https://docs-python.ru/tutorial/opredelenie-funktsij-python/peregruzka-funktsij/)>

## Подведение итогов

TODO

## Упражнения

1.  Создайте класс, который называется Thing, не имеющий содержимого, и выведите его на экран. Затем создайте объект example этого класса и также выведите его. Совпадают ли выведенные значения?

2.  Создайте новый класс с именем Thing2 и присвойте его атрибуту letters значение 'abc'. Выведите на экран значение атрибута letters.

3.  Создайте еще один класс, который, конечно же, называется Thing3. В этот раз присвойте значение 'xyz' атрибуту объекта, который называется letters. Выведите на экран значение атрибута letters. Понадобилось ли вам создавать объект класса, чтобы сделать это?

4.  Создайте класс, который называетсяElement, имеющий атрибуты объектаname, symbol и number. Создайте объект этого класса со значениями 'Hydrogen', 'H' и 1.

5.  Создайте словарь со следующими ключами и значениями: 'name': 'Hydrogen', 'symbol': 'H', 'number': 1. Далее создайте объект с именем hydrogen класса Element с помощью этого словаря.

6.  Для класса Element определите метод с именем dump(), который выводит на экран значения атрибутов объекта (name, symbol и number). Создайте объект hydrogen из этого нового определения и используйте метод dump(), чтобы вывести на экран его атрибуты.

7.  Вызовите функцию print(hydrogen). В определении класса Element измените имя метода dump на \_\_str\_\_, создайте новый объект hydrogen и затем снова вызовите метод print(hydrogen).

8.  Модифицируйте класс Element, сделав атрибуты name, symbol и number закрытыми. Определите для каждого атрибута свойство получателя, возвращающее значение соответствующего атрибута.

9.  Определите три класса: Bear, Rabbit и Octothorpe. Для каждого из них определите всего один метод — eats(). Он должен возвращать значения 'berries' (для Bear), 'clover' (для Rabbit) или 'campers' (для Octothorpe). Создайте по одному объекту каждого класса и выведите на экран то, что ест указанное животное.

10. Определите три класса: Laser, Claw и SmartPhone. Каждый из них имеет только один метод — does(). Он возвращает значения 'disintegrate' (для Laser), 'crush' (для Claw) или 'ring' (для SmartPhone). Далее определите класс Robot, который содержит по одному объекту каждого из этих классов. Определите метод does() для класса Robot, который выводит на экран все, что делают его компоненты.