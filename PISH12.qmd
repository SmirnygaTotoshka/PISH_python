# Numpy

## Введение

Numpy (Numerical python) - мощная и высокопроизводительная библиотека для математических вычислений и линейной алгебры. Секрет её производительности в том, что она является оберткой для функций, написанных на языке C. На типах данных, функциях и принципах, заложенных в этой библиотеке, основываются основные библиотеки для анализа данных на Python, такие как pandas, scipy. Numpy имеет свой [официальный сайт](https://numpy.org/), хорошую документацию и обучающие материалы с примерами. Библиотека легко устанавливается как через conda,

``` bash
conda install -c conda-forge numpy
```

так и через pip.

``` bash
pip install numpy
```

Чтобы проверить корректность установки, выполните следующий код.

```{python}
import numpy as np # Общепринятый псевдоним
print(np.__version__)
```

## Массивы

Основным типом данных в numpy является гомогенный многомерный массив (numpy.ndarray или array). Гомогенный - состоящий из объектов одного типа. Создать такой массив можно из просто списка python. Следующий пример иллюстрирует основные атрибуты объекта ndarray.

``` python

example = np.array([[1,2,3,4,5],[6,7,8,9,0]])
print(f"Количество осей {example.ndim}") # <1> 
print(f"Форма массива {example.shape}") # <2> 
print(f"Количество элементов {example.size}") # <3> 
print(f"Тип элементов {example.dtype}") # <4> 
print(f"Размер элемента в байтах {example.itemsize}") # <5>
```

1.  В нашем случае двумерный массив
2.  2 строки 5 столбцов
3.  10 элементов
4.  типы элементов из языка C. Цифра на конце - количество бит
5.  Количество байт занимаемых одним элементом массива

Типы данных отличаются от встроенных в Python. Это никак не влияет напрямую на их использование, и с этмими типами можно совершать всё те же арифметические и логические операции. Язык С, на котором написана библиотека, является компилируемым языком с строгой типизацией, что позволяет значительно ускорить расчеты. Типы dtype используются только внутри библиотеки.

Рассмотрим способы создания массивов, кроме приведения типов.

``` python
# Массив нельзя создать следующим образом
# a = np.array(1, 2, 3, 4)

a = np.zeros((3, 4)) # <1>
b = np.ones((2, 3, 4), dtype=np.int16) # <2>
c = np.arange(10, 30, 5) # <3>
d = np.linspace(0, 2, 9) # <4>

print(a)
print(b)
print(c)
print(d)
```

1.  2-мерный массив из нулей формой 3 на 4
2.  3-мерный массив из нулей формой 2*3*4, в качестве типа - целые числа, на 1 число 2 байта
3.  Аналог функции range из стандартного питона. Число от 10 до 30 с шагом 5
4.  Линейное пространство. Создаются 9 точек распределенных от 0 до 2.

Кроме этого, numpy предоставляет функционал генеарции случайных массивов из различных распределений.

``` python
rng = np.random.default_rng()

a = rng.integers(0,10,5) # <1>
b = rng.uniform(1,10,5)  # <2>
c = rng.normal(10, 5, 2) # <3>
```

1.  5 целых чисел от 0 до 10 из равномерного распределения
2.  5 чисел от 1 до 10 из равномерного распределения
3.  10 чисел из нормального распределения с средним 5 и стандартным отклонением 2.

## Операции над массивами

Базовые арифметические и логические операции выполняются над массивами *поэлементно*. Иначе говорят, что эти операции *векторизированы*. Чтобы понять, что это означает, приведем простой пример: допустим над надо сложить два списка.

Пример реализации на чистом питоне.

``` python
a = [1,2,3,4,5]
b = [1,2,3,4,5]

c = []

for i in range(len(a)):
  c.append(a[i] + b[i])
  
c = list(map(lambda i: a[i] + b[i], range(len(a)))) # аналогичное решение в одно строку
```

Решение на numpy выглядит просто и элегантно.

```{python}

a = np.array([1,2,3,4,5])
b = np.array([1,2,3,4,5])
c = a + b
print(c)
```

Также и с логическими операциями

```{python}

a = np.array([20, 30, 40, 50])
a < 35
```

Простое умножение матриц будет работать поэлементно. Если вам нужно перемножить матрицы по математическому определению умножения матриц, то для этого есть оператор \@ или функция `dot`.

```{python}

A = np.array([[1, 1],
              [0, 1]])
B = np.array([[2, 0],
              [3, 4]])
print(A * B)    # elementwise product
print(A @ B)     # matrix product
print(A.dot(B))  # another matrix product
```

Для многомерных массивов, можно выполнять аггрегирующие операции вдоль некоторой оси (минимум, максимум, среднее, сумма и т.п.)

``` python
b = np.arange(12).reshape(3, 4) # <1>
b.sum(axis=0) # <2> 
b.min(axis=1) # <3> 
b.cumsum(axis=1) # <4>
```

1.  Изменение формы массива будет рассмотрено в следующем разделе
2.  Сумма по каждому столбцу
3.  Минимум по каждой строке
4.  Накопленная сумма по каждой строке

Кроме базовых операций в numpy определены так называемые универсальные математические функции: синус, косинус, экспонента, квадратный корень и многое другое.

```{python}

b = np.arange(12).reshape(3, 4)
print(np.sin(b))
print(np.exp(b))
```

Принципы индексации и выбора элементов для массивов numpy такие же, как и для списков python. Преимущество numpy в том, что он расширяет эти правила на многомерный случай, позволяя их применять вдоль каждой оси, перечисляя интервалы через запятую.

``` python
b = np.arange(12).reshape(3, 4)
print(b[-2, 0:2]) 
```

numpy предоставляет функционал для изменения форма массивов. Уже использовалась выше функция `reshape`. Она меняет по возможности форму массива. Например `arange` создает массив формой (12) и с помощью `reshape` преобразуем его в двумерной с формой 3 на 4.

`reshape` используют для создания многомерных массивов или для манипуляцийс многомерными массивами. Если вам необходимо "спрямить" матрицу, т.е. сделать из многомерного массива одномерный, существует функция `ravel`.

``` python
a = np.arange(12).reshape(3, 4)
b = a.ravel()
print(a) 
print(b)
```

Важный момент: присвоение существующего массива другой переменной, не создает копии массива. В переменной всего лишь хранится адрес на этот массив. Поэтому, если вы измените знаение по одной переменной, то вдругой оно также изменится. Для создания копии массива используйте метод `copy`.

## Упражения

1.  Сгенерируйте массив из 30 чисел из стандартного нормального распределения. Преобразуйте его в двумерную матрицу 5\*6. Рассчитайте среднее по столбцам. Реализуйте алгоритм на numpy и на чистом питоне. Сравните время, которое вы потратили на написание, время выполнения (модкль time) и затраченную память ([`sys.getsizeof`](http://docs.python.org/2/library/sys.html#sys.getsizeof)).
2.  Напишите функцию для решения системы линейных алгебраических уравнений мтеодом Крамера с использованием numpy. Сравните с выводом функции numpy.linalg.solve.
3.  Создайте двумерную матрицу 10\*10 элементов из случайных чисел от -100 до 100. Создайте подмассив из изначального массива, состоящего только из положительных чисел. Какую форму он имеет? Какое число минимальное, какое максимальное, какое среднее?

## Подведение итогов

numpy - мощная библиотека для работы с массивами объектов (не ограничивается только числами). Она работает гораздо быстрее, чем обычные списки, потребляет меньше памяти и предоставляет широкий функционал для работы с массивами любой размерности. На этой библиотеке построены более продвинутые библиотеки для научных вычислений и анализа данных: pandas и scipy. Старайтесь использовать масссивы numpy для ускорения работы вашего кода.

##