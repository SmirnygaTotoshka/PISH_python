# Введение в объектно-ориентированное программирование. Инкапсуляция

## Введение

В парадигме объектно-ориентированного программирования основной структурно-функциональной единицей служит **объект** - абстракция (модель), упрощенное представление окружающих нас предметов и/или явлений. Каждый объект обладает некоторыми **свойствами** и некоторым **поведением**. Причем программисты ни в коем случае не стремятся построить полную модель некоторого объекта, а берут только те свойства и то поведение, которое необъодимо для решения поставленной задачи. Свойства в программировании выражаются *переменными*, поведение - *функциями*.

Объекты бывают разных типов и перед их использованием необходимо их создать. Для этого нужно создать "чертёж", шаблон, описывающий свойства и поведение объекта. Такие шаблоны называются **классами**.

```{python}
# определение самого простого пустого класса. Определение начинается с ключевого слова class. Затем идет имя класса и двоеточие
# заглушка pass позволяет нам избежать синтаксической ошибки из-за незаконченности
# Каждый класс уже обладает набором стандартных методов (например, приведение класса к строке)
class Cat:
    pass
  
# Так мы создаем конкретный объект (экземпляр класса). ИмяКласса() - специальная функция, создающаяя объект - конструктор.
cat = Cat()
print(cat)
```

Объектно-ориентированное программирование (ООП) базируется на 3 основопоагающих принципах:

1.  Инкапсуляция - управление доступом к свойствам и поведению объекта
2.  Наследование - передача свойств и поведения от класса-родителя к классу-наследнику.
3.  Полиморфизм - возможность создавать различные реализации одной абстрактной сущности.

Полиморфизм (множество форм) реализуется с помощью наследования, когда мы можем создать иерархию классов: от самого абстрактного к конкретной реализации.

![Схема](images/10_hierarchy.png)

Все классы в языке уже являются наследниками класса object. Каждый класс будет наследовать черты своего родителя, но обладать отличной от родителя реализацией.

Сегодняшний разговор будет об инкапсуляции, принципе который позволяет создавать безопасные интерфейсы взаимодействия с объектами за счет управления областью видимости дял окружения свойств и повдеения.

```{python}
class Cat:
    """
    Дадим некоторой конкретики нашим котикам. 
    Дадим им кличку, цвет шерсти и простое поведение (интерфейс взаимодействия с объектом): 
    они должны говорить нам, как их зовут и какой у них цвет шерсти.
    """

    def __init__(self, cat_name, fur_color):# Сигнатура функции
        """
         Одна из реализациий полиморфизма - переопределение (задание новой реализации) функций.
         Здесь мы переопределяем конструктор, стандартную функцию унаследованную от object.
         Имена таких функций начинаются и заканчиваются с двух нижних подчеркиваний.
         
         Первым аргументом в сигнатуре функций внутри классов ВСЕГДА идёт self. С помощью self мы получаем доступ к содержимому самого класса.
        
         Помним о нотации
         
         object_name.wanted_property - обращение к свойству некоторого объекта.

         object_name.wanted_fun() - вызов функции некоторого объекта

         self.wanted_property - обращение к свойству класса внутри класса

         self.wanted_function() - вызов функции класса внутри класса
         
         В конструкторе мы инициализируем (задаём) свойства объекта. Их можно задавать в любом месте класса, здесь только те, которые нужны при создании
         Конструкторов может быть несколько в классе.
        """
        self.name = cat_name # Читаем как свойство самого класса равно параметру cat_name
        self.fur_color = fur_color
        
    # Поведение выражается через функции. Поэтому здесь реалзиуем функции, которые должен уметь делать котик ПО ЗАДАНИЮ!
    # Это обычные функции, только внутри класса. Не забываем про self 
    def who(self):
        print(f"My name is {self.name}.")
        
    def looking(self):
        return f"I have {self.fur_color} fur!"
```

```{python}
# Создаем экземпляр котика путем вызова конструктора с конкретными значениями аргументов и просим котика представиться.
kitty_example = Cat("Murzik", "orange")
kitty_example.who()
```

```{python}
# Какая же шерсть у котика?
murzik_fur_color = kitty_example.looking()
print(murzik_fur_color)
```

## Задание

Реализуйте по аналогии класс Собака. Свойства: кличка и порода. Поведение: представиться (назвать кличку и породу), гавкать.

### Ответ

```{python}
class Dog:
    
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed
        
    def who(self):
        print(f"My name is {self.name}. My breed is {self.breed}.")
        
    def bark(self):
        print("Hoof Hoof!")
        
doggy = Dog("Bobby","redneck")
doggy.who()
doggy.bark()
```

## Управление доступом

Существуют три уровня доступа:

-   открытый (public) - переменная или функция доступна всем
-   защищенный (protected) - переменная или функция доступна только самому классу и его наследникам.
-   скрытый (private) - переменная или функция доступна только самому классу

Открытый уровень доступа означает, что ничего не мешает нам в любом месте обратиться к переменной или функции объекта и/или изменить его состояние. Это небезопасно, поэтому рекомендуется разделять переменный и функции по области видимости, оставляя открытой как можно меньшую часть программы.

```{python}
# Мы так можем сделать в случае публичного доступа
doggy.name
```

В Python все переменные и функции класса являются изначально открытыми. Разделение уровней доступа происходит на уровне соглашений имён.

-   Имя скрытой переменной/функции начинается с двух нижних подчеркиваний
-   Имя защищённой переменной/функции начинается с одного нижнего подчеркивания

```{python}
class Penguin:
    
    def __init__(self, name, color):
        self.__name = name # Приватное поле name
        self.__color = color
        
    def __get_info(self):#Приватная функция
        print(f"penguin {self.__name} {self.__color}")
```

```{python}
#| error: true
p = Penguin("Gerda", "black")
p.__name
```

```{python}
#| error: true

p.__get_info()
```

Как можно заметить, обратиться к скрытым полям и вызвать скрытую функцию снаружи класса напрямую нельзя. Способ есть, но в педагогических целях не показывается, потому что так делать плохо!

Программисты могут управлять доступом к скрытым или защищенным полям с помощью определения специальных функций, которые на жаргоне называют геттеры (для чтения) и сеттеры (для изменения). Наличие этих функций определяет права на эту переменную снаружи класса для пользователя. Их можно определять как обычные функции, а можно оборачивать их в специальные **декораторы**. Будет продемонстрировано оба подхода.

Декораторы будут разобраны на дальнейших занятиях. Пока следует знать, что это приспособления для расширения текущих возможностей без изменения уже имеющихся.

```{python}
class Penguin:
    # реализация через обычные геттеры/сеттеры
    def __init__(self, name, color):
        self.__name = name # Приватное поле name
        self.__color = color

    # Геттер. Просто возвращает значение скрытого атрибута. Таккой геттер ещё называют тривиальным
    def get_name(self):
        return self.__name
    # Сеттер. Просто изменяет значение скрытого атрибута.
    def set_name(self, new_name):
        self.__name = new_name
    
p = Penguin("Helga","black")
print(f"My first name is {p.get_name()}")
p.set_name("Olga")
print(f"Now my name is {p.get_name()}")
```

```{python}
class Penguin:
    # Реализация через декораторы
    # такая реализация наиболее принята в Python
    def __init__(self, name):
        self.__name = name
    
    @property# Так функция оборачивается в декоратор. @имя_декоратора над сигнатурой функции
    def name(self):
        return self.__name
    # Здесь важно обратить фнимание на имя декоратора. @property_name.setter
    # Вместо property_name имя соответствующей функции с декоратором property
    @name.setter
    def name(self, new_name):
        self.__name = new_name
        
p = Penguin("Helga")
print(f"My first name is {p.name}")
p.name = "Olga"
print(f"Now my name is {p.name}")
```

По сути мы заменили вызов функции на обращение к переменной, что является более быстрой операцией

```{python}
type(p.name)
```

Свойство может возвращать не только значение, но измененное по какой-то логике. Если отсутствует сеттер, мы не сможем его изменить. Взгляните внимательно на пример с классом Круг. Для его создание необходим радиус, но мы можем также определить свойство диаметра, которое пользователь не сможет изменить, что логично, т.к. он зависит от радиуса.

```{python}
class Circle:
    
    def __init__(self, radius):
        self.__radius = radius
        
    @property
    def diametr(self):
        return 2 * self.__radius
```

```{python}
c = Circle(5)
c.diametr
```

Попытка изменить диаметр не увенчается успехом, что является признаком безопасности: если радиус и диаметр будут зависеть друг от друга как-то иначе, это повлияет на логику программы непредсказуемым для программиста способом.

```{python}
#| error: true

c.diametr = 13
```

## Подведение итогов

1.  Python является объектно-ориентированным языком, следовательно, каждая сущность в нем является объектом.
2.  Объект - это некоторая модель для решения нужной нам задачи. Объект обладает свойствами и поведением.
3.  Экземпляр объекта создается по некоторому плану, чертежу, называемым классом. В классе можно и нужно разделять доступ к свойствам и поведению для окружения в целях безопасности.

## Задание

Реализуйте класс треугольник. Стороны должны быть скрытыми свойствами. Реализуйте свойства периметр и площадь (теорема Герона). Реализуйте в конструкторе проверку на треугольность (теорема о соотношении сторон треугольника), в случае нарушения выбрасывайте исключение, которое в дальнейшем будете обрабатывать. Реализуйте функцию внутри класса для расчета углов между сторонами треугольника. Напишите программу для демонстрации возможностей класса.